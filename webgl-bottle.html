<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Botella 3D Krautermeister</title>
  <style>
    * { margin: 0; padding: 0; }
    html, body { width: 100%; height: 100%; }
    body { background: linear-gradient(135deg, #0a1410 0%, #1a2f26 100%); }
    canvas { display: block; width: 100%; height: 100%; }
    #status {
      position: fixed;
      top: 20px;
      right: 20px;
      padding: 15px 25px;
      background: #4ade80;
      color: white;
      border-radius: 10px;
      font-weight: bold;
      font-size: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="status">✅ Botella rendering</div>

  <script>
    // WebGL Shader Vertex
    const vsSource = `
      attribute vec3 aPosition;
      attribute vec3 aNormal;
      
      uniform mat4 uMatrix;
      uniform mat4 uNormal;
      
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        gl_Position = uMatrix * vec4(aPosition, 1.0);
        vNormal = normalize(vec3(uNormal * vec4(aNormal, 0.0)));
        vPosition = aPosition;
      }
    `;
    
    // WebGL Shader Fragment
    const fsSource = `
      precision mediump float;
      
      varying vec3 vNormal;
      varying vec3 vPosition;
      
      void main() {
        // Color verde/marrón oscuro
        vec3 color = vec3(0.15, 0.25, 0.18);
        
        // Luz simple
        vec3 light = normalize(vec3(1.0, 1.0, 1.0));
        float brightness = max(dot(vNormal, light), 0.3);
        
        // Highlights naranja
        vec3 highlight = vec3(1.0, 0.6, 0.3) * pow(brightness, 2.0) * 0.5;
        
        vec3 finalColor = color * brightness + highlight;
        
        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;
    
    // Crear escena WebGL
    const canvas = document.getElementById('canvas');
    const gl = canvas.getContext('webgl');
    
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    
    gl.viewport(0, 0, canvas.width, canvas.height);
    gl.clearColor(0.04, 0.09, 0.06, 1.0);
    gl.enable(gl.DEPTH_TEST);
    
    // Compilar shaders
    function compileShader(source, type) {
      const shader = gl.createShader(type);
      gl.shaderSource(shader, source);
      gl.compileShader(shader);
      if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
        console.error('Shader error:', gl.getShaderInfoLog(shader));
      }
      return shader;
    }
    
    const vs = compileShader(vsSource, gl.VERTEX_SHADER);
    const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);
    
    // Crear programa
    const program = gl.createProgram();
    gl.attachShader(program, vs);
    gl.attachShader(program, fs);
    gl.linkProgram(program);
    gl.useProgram(program);
    
    // Crear geometría de botella (cilindro simple)
    function createBottleGeometry() {
      const vertices = [];
      const normals = [];
      const indices = [];
      
      // Parámetros de la botella
      const segments = 32;
      const rings = 40;
      
      // Generar cilindro con forma de botella
      for (let ring = 0; ring <= rings; ring++) {
        const y = -1.5 + (ring / rings) * 3;
        
        // Radio varía según altura para forma de botella
        let radius = 0.3;
        if (ring < rings * 0.3) {
          radius = 0.15; // cuello
        } else if (ring < rings * 0.4) {
          radius = 0.15 + (ring - rings * 0.3) / (rings * 0.1) * 0.15;
        } else if (ring < rings * 0.7) {
          radius = 0.3; // barriga
        } else {
          radius = 0.3 - (ring - rings * 0.7) / (rings * 0.3) * 0.15;
        }
        
        for (let seg = 0; seg <= segments; seg++) {
          const theta = (seg / segments) * Math.PI * 2;
          const x = Math.cos(theta) * radius;
          const z = Math.sin(theta) * radius;
          
          vertices.push(x, y, z);
          
          // Normal apunta hacia afuera
          const nx = Math.cos(theta);
          const nz = Math.sin(theta);
          normals.push(nx, 0, nz);
          
          // Índices
          if (ring < rings && seg < segments) {
            const a = ring * (segments + 1) + seg;
            const b = a + 1;
            const c = a + (segments + 1);
            const d = c + 1;
            
            indices.push(a, c, b);
            indices.push(b, c, d);
          }
        }
      }
      
      const vertexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
      
      const normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normals), gl.STATIC_DRAW);
      
      const indexBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
      
      return {
        vertex: vertexBuffer,
        normal: normalBuffer,
        index: indexBuffer,
        count: indices.length
      };
    }
    
    const bottle = createBottleGeometry();
    
    // Preparar atributos
    const aPosition = gl.getAttribLocation(program, 'aPosition');
    const aNormal = gl.getAttribLocation(program, 'aNormal');
    const uMatrix = gl.getUniformLocation(program, 'uMatrix');
    const uNormal = gl.getUniformLocation(program, 'uNormal');
    
    // Función de matriz
    function rotationMatrix(angle) {
      const c = Math.cos(angle);
      const s = Math.sin(angle);
      return [
        c, 0, -s, 0,
        0, 1, 0, 0,
        s, 0, c, 0,
        0, 0, 0, 1
      ];
    }
    
    function perspectiveMatrix(fov, aspect, near, far) {
      const f = 1 / Math.tan(fov / 2);
      const nf = 1 / (near - far);
      return [
        f / aspect, 0, 0, 0,
        0, f, 0, 0,
        0, 0, (far + near) * nf, -1,
        0, 0, (2 * far * near) * nf, 0
      ];
    }
    
    function multiply(a, b) {
      const result = [];
      for (let i = 0; i < 4; i++) {
        for (let j = 0; j < 4; j++) {
          let sum = 0;
          for (let k = 0; k < 4; k++) {
            sum += a[i * 4 + k] * b[k * 4 + j];
          }
          result[i * 4 + j] = sum;
        }
      }
      return result;
    }
    
    // Render loop
    let angle = 0;
    function render() {
      angle += 0.01;
      
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      
      // Matrices
      const aspect = canvas.width / canvas.height;
      const perspective = perspectiveMatrix(Math.PI / 4, aspect, 0.1, 100);
      const rotation = rotationMatrix(angle);
      const matrix = multiply(perspective, rotation);
      
      // Configurar atributos
      gl.bindBuffer(gl.ARRAY_BUFFER, bottle.vertex);
      gl.vertexAttribPointer(aPosition, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aPosition);
      
      gl.bindBuffer(gl.ARRAY_BUFFER, bottle.normal);
      gl.vertexAttribPointer(aNormal, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(aNormal);
      
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bottle.index);
      
      // Pasar matrices
      gl.uniformMatrix4fv(uMatrix, false, matrix);
      gl.uniformMatrix4fv(uNormal, false, rotation);
      
      // Dibujar
      gl.drawElements(gl.TRIANGLES, bottle.count, gl.UNSIGNED_SHORT, 0);
      
      requestAnimationFrame(render);
    }
    
    render();
    
    // Resize
    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      gl.viewport(0, 0, canvas.width, canvas.height);
    });
    
    console.log('✅ Botella WebGL renderizada (sin dependencias externas)');
  </script>
</body>
</html>
